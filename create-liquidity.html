<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Create Liquidity | SolMint</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.73.0/lib/index.iife.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@solana/spl-token@0.3.8/lib/index.iife.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@raydium-io/raydium-sdk@1.3.1/dist/index.iife.js"></script>
</head>
<body class="bg-gray-50 font-sans">
    <!-- Header -->
    <header class="bg-blue-600 text-white p-6">
        <div class="flex justify-center items-center flex-col">
            <h1 class="text-3xl font-bold">SolMint</h1>
            <nav class="mt-4 flex justify-center space-x-8">
                <a href="create-token.html" class="bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 transition duration-300">
                    Create Token
                </a>
                <a href="create-liquidity.html" class="bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 transition duration-300">
                    Create Liquidity Pool
                </a>
                <button id="connectWalletButton" onclick="showWalletModal()" class="bg-blue-500 text-white py-2 px-4 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400">
                    Connect Wallet
                </button>
                <select id="networkSelect" onchange="updateNetwork()" class="bg-white text-blue-600 border rounded-md py-2 px-4 hover:border-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-600 transition duration-300">
                    <option value="devnet">Devnet</option>
                    <option value="testnet">Testnet</option>
                    <option value="mainnet">Mainnet</option>
                </select>
            </nav>
        </div>
    </header>

    <!-- Wallet Selector Modal -->
    <div id="walletModal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center">
        <div class="bg-white rounded-lg p-6 max-w-sm w-full mx-4">
            <h3 class="text-xl font-bold mb-4">Select Wallet</h3>
            <div class="space-y-4">
                <button onclick="connectSpecificWallet('phantom')" class="w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 flex items-center justify-center">
                    <img src="https://phantom.app/img/phantom-logo.svg" class="w-6 h-6 mr-2" alt="Phantom">
                    Phantom
                </button>
                <button onclick="connectSpecificWallet('solflare')" class="w-full bg-orange-600 text-white py-2 px-4 rounded-md hover:bg-orange-700 flex items-center justify-center">
                    <img src="https://solflare.com/favicon.ico" class="w-6 h-6 mr-2" alt="Solflare">
                    Solflare
                </button>
            </div>
            <button onclick="closeWalletModal()" class="mt-4 w-full border border-gray-300 text-gray-700 py-2 px-4 rounded-md hover:bg-gray-100">
                Cancel
            </button>
        </div>
    </div>

    <main class="p-8 grid grid-cols-1 md:grid-cols-2 gap-8">
        <!-- Liquidity Creation Section -->
        <section class="bg-white p-6 rounded-lg shadow-lg">
            <h2 class="text-2xl font-bold mb-6">Create Liquidity</h2>
            <form>
                <label for="baseToken" class="block text-sm font-medium">Base Token</label>
                <select id="baseToken" class="w-full p-3 border rounded-md mb-4">
                </select>
                <label for="quoteToken" class="block text-sm font-medium">Quote Token</label>
                <select id="quoteToken" class="w-full p-3 border rounded-md mb-4">
                </select>
                <label for="liquidityAmount" class="block text-sm font-medium">Liquidity Amount</label>
                <input type="number" id="liquidityAmount" class="w-full p-3 border rounded-md mb-4" placeholder="Enter amount">
                <label for="feeTier" class="block text-sm font-medium">Fee Tier</label>
                <select id="feeTier" class="w-full p-3 border rounded-md mb-4">
                    <option value="0.25">0.25%</option>
                    <option value="0.5">0.5%</option>
                    <option value="1">1%</option>
                    <option value="2">2%</option>
                    <option value="4">4%</option>
                </select>
                <button id="createLiquidityButton" class="bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700">Create Liquidity</button>
            </form>
        </section>
        <section class="bg-white p-6 rounded-lg shadow-lg">
            <h2 class="text-2xl font-bold mb-6">How Liquidity Pools Work</h2>
            <p class="text-gray-700 mb-4">
                A liquidity pool is a collection of funds locked in a smart contract. These pools are used by decentralized exchanges (DEXes) to facilitate trading. By contributing to liquidity pools, you help ensure that there is enough supply for traders to execute buy and sell orders.
            </p>
            <p class="text-gray-700 mb-4">
                When you add liquidity to a pool, you provide two assets (such as SOL and USDC) in a specific ratio. The pool facilitates trades between these assets. In return, you earn a portion of the transaction fees generated by the trades within the pool, based on the amount of liquidity youâ€™ve contributed.
            </p>
            <p class="text-gray-700 mb-4">
                The fee you can earn depends on the fee tier set for the pool. The higher the fee tier, the higher the reward for liquidity providers. However, this also comes with increased risk, as prices can fluctuate more significantly at higher fee tiers.
            </p>
            <p class="text-gray-700">
                Liquidity pools play a vital role in decentralized finance (DeFi) by improving market efficiency, reducing slippage, and providing users with an opportunity to earn passive income from their digital assets.
            </p>
        </section>
    </main>

    <footer class="bg-blue-600 text-white p-6 text-center mt-auto">
        <div class="container mx-auto">
            <p>&copy; 2024 SolMint</p>
        </div>
    </footer>

    <script>
        // Initialize Solana connection and state
        let connection;
        let walletPublicKey = null;
        let selectedNetwork = localStorage.getItem('selectedNetwork') || 'devnet';
        let currentWallet = null;

        // Initialize connection on page load
        window.addEventListener('load', () => {
            initializeConnection(selectedNetwork);
            populateBaseTokenDropdown();
            document.getElementById('networkSelect').value = selectedNetwork;
        });

        function initializeConnection(network) {
            const networks = {
                'devnet': 'https://api.devnet.solana.com',
                'testnet': 'https://api.testnet.solana.com',
                'mainnet': 'https://api.mainnet-beta.solana.com'
            };
            connection = new solanaWeb3.Connection(networks[network]);
        }

        function showWalletModal() {
            document.getElementById('walletModal').classList.remove('hidden');
        }

        function closeWalletModal() {
            document.getElementById('walletModal').classList.add('hidden');
        }

        async function connectSpecificWallet(walletName) {
            try {
                let wallet;
                if (walletName === 'phantom') {
                    if (!window.solana || !window.solana.isPhantom) {
                        alert("Phantom wallet is not installed. You will be redirected to install it.");
                        window.open("https://phantom.app/", "_blank");
                        return;
                    }
                    wallet = window.solana;
                } else if (walletName === 'solflare') {
                    if (!window.solflare) {
                        alert("Solflare wallet is not installed. You will be redirected to install it.");
                        window.open("https://solflare.com/", "_blank");
                        return;
                    }
                    wallet = window.solflare;
                }

                // Disconnect any existing wallet connection
                if (currentWallet) {
                    await disconnectWallet();
                }

                currentWallet = wallet;
                const resp = await wallet.connect();
                walletPublicKey = resp.publicKey.toString();
                
                // Update button text and state
                const connectButton = document.getElementById('connectWalletButton');
                connectButton.textContent = `${walletName.charAt(0).toUpperCase() + walletName.slice(1)} (${walletPublicKey.slice(0, 4)}...${walletPublicKey.slice(-4)})`;
                connectButton.onclick = disconnectWallet;

                // Ensure wallet is on the correct network
                await switchWalletNetwork(selectedNetwork);
                closeWalletModal();

                // Save wallet preference
                localStorage.setItem('lastUsedWallet', walletName);

                // Refresh token dropdowns after wallet connection
                populateBaseTokenDropdown();
            } catch (err) {
                console.error("Error connecting to wallet:", err);
                if (err.code === 4001) {
                    alert("Wallet connection was rejected by the user.");
                } else {
                    alert("Failed to connect to wallet: " + err.message);
                }
                currentWallet = null;
                walletPublicKey = null;
            }
        }

        async function disconnectWallet() {
            try {
                if (currentWallet) {
                    await currentWallet.disconnect();
                    localStorage.removeItem('lastUsedWallet');
                }
            } catch (err) {
                console.error("Error disconnecting wallet:", err);
            } finally {
                // Always reset the state and UI, even if disconnect fails
                walletPublicKey = null;
                currentWallet = null;
                
                // Reset button
                const connectButton = document.getElementById('connectWalletButton');
                connectButton.textContent = 'Connect Wallet';
                connectButton.onclick = showWalletModal;

                // Refresh token dropdowns after wallet disconnection
                populateBaseTokenDropdown();
            }
        }

        async function updateNetwork() {
            const network = document.getElementById('networkSelect').value;
            selectedNetwork = network;
            localStorage.setItem('selectedNetwork', network);
            
            // Reinitialize connection with new network
            initializeConnection(network);

            // Refresh token dropdowns with new network's tokens
            populateBaseTokenDropdown();

            // If wallet is connected, switch its network
            if (currentWallet && walletPublicKey) {
                try {
                    await switchWalletNetwork(network);
                } catch (err) {
                    console.error("Error switching network:", err);
                    alert("Failed to switch network. Please try reconnecting your wallet.");
                }
            }
        }

        async function switchWalletNetwork(network) {
            try {
                if (currentWallet) {
                    if (currentWallet === window.solana) {
                        // Phantom wallet
                        await currentWallet.request({
                            method: 'wallet_switchNetwork',
                            params: { network }
                        });
                    } else if (currentWallet === window.solflare) {
                        // Solflare wallet
                        await currentWallet.switchNetwork(network);
                    }
                }
            } catch (err) {
                console.error("Error switching network in wallet:", err);
                alert("Failed to switch network in wallet. Please switch manually in your wallet.");
            }
        }

        // Function to populate token dropdowns
        function populateBaseTokenDropdown() {
            const baseTokenDropdown = document.getElementById("baseToken");
            const quoteTokenDropdown = document.getElementById("quoteToken");
            const createdTokens = JSON.parse(localStorage.getItem("createdTokens")) || [];

            // Default options
            const defaultOptions = `
                <option value="SOL">SOL (Solana)</option>
                <option value="USDC">USDC</option>
                <option value="USDT">USDT</option>
            `;

            baseTokenDropdown.innerHTML = defaultOptions;
            quoteTokenDropdown.innerHTML = defaultOptions;

            // Add created tokens to the dropdowns
            createdTokens.forEach(token => {
                const baseOption = document.createElement("option");
                const quoteOption = document.createElement("option");
                
                baseOption.value = token;
                baseOption.innerText = token;
                quoteOption.value = token;
                quoteOption.innerText = token;
                
                baseTokenDropdown.appendChild(baseOption);
                quoteTokenDropdown.appendChild(quoteOption);
            });
        }

        // Handle form submission
        document.querySelector("form").addEventListener("submit", async function(event) {
            event.preventDefault();
            
            if (!walletPublicKey) {
                alert('Please connect your wallet first');
                return;
            }

            const baseToken = document.getElementById("baseToken").value;
            const quoteToken = document.getElementById("quoteToken").value;
            const liquidityAmount = parseFloat(document.getElementById("liquidityAmount").value);
            const feeTier = parseFloat(document.getElementById("feeTier").value);
            
            // Validation
            if (baseToken === quoteToken) {
                alert('Base token and quote token must be different');
                return;
            }

            if (isNaN(liquidityAmount) || liquidityAmount <= 0) {
                alert('Please enter a valid liquidity amount greater than 0');
                return;
            }

            try {
                document.getElementById("createLiquidityButton").disabled = true;
                document.getElementById("createLiquidityButton").textContent = "Creating Pool...";
                
                await createLiquidityPool(baseToken, quoteToken, liquidityAmount, feeTier);
                alert('Liquidity pool created successfully!');
            } catch (error) {
                alert("Failed to create liquidity pool: " + error.message);
            } finally {
                document.getElementById("createLiquidityButton").disabled = false;
                document.getElementById("createLiquidityButton").textContent = "Create Liquidity";
            }
        });

        async function createLiquidityPool(baseToken, quoteToken, liquidityAmount, feeTier) {
            try {
                if (!walletPublicKey) {
                    throw new Error('Wallet is not connected');
                }

                console.log(`Creating liquidity pool on ${selectedNetwork}:`);
                console.log(`Base Token: ${baseToken}`);
                console.log(`Quote Token: ${quoteToken}`);
                console.log(`Amount: ${liquidityAmount}`);
                console.log(`Fee Tier: ${feeTier}%`);

                // Get token mint addresses
                const baseTokenMint = await getTokenMintAddress(baseToken);
                const quoteTokenMint = await getTokenMintAddress(quoteToken);

                // Create associated token accounts if they don't exist
                const baseTokenAccount = await createAssociatedTokenAccountIfNotExists(
                    baseTokenMint,
                    new solanaWeb3.PublicKey(walletPublicKey)
                );
                
                const quoteTokenAccount = await createAssociatedTokenAccountIfNotExists(
                    quoteTokenMint,
                    new solanaWeb3.PublicKey(walletPublicKey)
                );

                // Initialize Raydium SDK
                const RAYDIUM_PROGRAM_ID = getRaydiumProgramId(selectedNetwork);
                
                // Create the pool settings
                const poolConfig = {
                    baseMint: baseTokenMint,
                    quoteMint: quoteTokenMint,
                    baseAmount: new BN(liquidityAmount * (10 ** 9)), // Assuming 9 decimals
                    quoteAmount: new BN(liquidityAmount * (10 ** 9)), // Equal amounts for initial liquidity
                    startPrice: 1, // 1:1 ratio for initial pool
                    feeTier: feeTier * 100 // Convert percentage to basis points
                };

                // Create transaction for pool creation
                const transaction = await createRaydiumPoolTransaction(
                    connection,
                    poolConfig,
                    new solanaWeb3.PublicKey(walletPublicKey),
                    baseTokenAccount,
                    quoteTokenAccount
                );

                // Sign and send transaction
                const signedTransaction = await currentWallet.signTransaction(transaction);
                const txId = await connection.sendRawTransaction(signedTransaction.serialize());
                
                console.log('Waiting for transaction confirmation...');
                const confirmation = await connection.confirmTransaction(txId, 'confirmed');
                
                if (confirmation.value.err) {
                    throw new Error('Transaction failed to confirm');
                }

                console.log('Liquidity pool created successfully on Raydium!');
                console.log('Transaction ID:', txId);
                
                // Save pool info to localStorage
                const poolInfo = {
                    baseToken,
                    quoteToken,
                    txId,
                    timestamp: Date.now()
                };
                const pools = JSON.parse(localStorage.getItem('createdPools') || '[]');
                pools.push(poolInfo);
                localStorage.setItem('createdPools', JSON.stringify(pools));

                return txId;
            } catch (error) {
                console.error('Error creating liquidity pool:', error);
                throw error;
            }
        }

        function getRaydiumProgramId(network) {
            const programIds = {
                'mainnet': 'RVKd61ztZW9GUwhRbbLoYVRE5Xf1B2tVscKqwZqXgEr',
                'devnet': '27haf8L6oxUeXrHrgEgsexjSY5hbVUWEmvv9Nyxg8vQv',
                'testnet': '27haf8L6oxUeXrHrgEgsexjSY5hbVUWEmvv9Nyxg8vQv'
            };
            return new solanaWeb3.PublicKey(programIds[network]);
        }

        async function createRaydiumPoolTransaction(connection, poolConfig, userPublicKey, baseTokenAccount, quoteTokenAccount) {
            const { baseMint, quoteMint, baseAmount, quoteAmount, startPrice, feeTier } = poolConfig;
            
            // Get Raydium pool program
            const ammProgram = new raydium.Program(connection, getRaydiumProgramId(selectedNetwork));
            
            // Calculate pool token mint address (PDA)
            const [poolTokenMint] = await solanaWeb3.PublicKey.findProgramAddress(
                [
                    Buffer.from('amm_pool'),
                    baseMint.toBuffer(),
                    quoteMint.toBuffer()
                ],
                ammProgram.programId
            );

            // Create pool token account
            const poolTokenAccount = await createAssociatedTokenAccountIfNotExists(
                poolTokenMint,
                userPublicKey
            );

            // Create the AMM pool account
            const [ammAccount] = await solanaWeb3.PublicKey.findProgramAddress(
                [
                    Buffer.from('amm_account'),
                    poolTokenMint.toBuffer()
                ],
                ammProgram.programId
            );

            // Create transaction
            const transaction = new solanaWeb3.Transaction();

            // Add create pool instruction
            const createPoolIx = await ammProgram.createPool({
                poolTokenMint,
                ammAccount,
                baseMint,
                quoteMint,
                baseTokenAccount,
                quoteTokenAccount,
                poolTokenAccount,
                userPublicKey,
                baseAmount,
                quoteAmount,
                startPrice,
                feeTier
            });

            transaction.add(createPoolIx);

            // Get recent blockhash
            const { blockhash } = await connection.getRecentBlockhash();
            transaction.recentBlockhash = blockhash;
            transaction.feePayer = userPublicKey;

            return transaction;
        }

        async function getTokenMintAddress(tokenSymbol) {
            // Common token addresses across networks
            const tokenAddresses = {
                'mainnet': {
                    'SOL': 'So11111111111111111111111111111111111111112',
                    'USDC': 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
                    'USDT': 'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB',
                    'RAY': '4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R'
                },
                'devnet': {
                    'SOL': 'So11111111111111111111111111111111111111112',
                    'USDC': 'Gh9ZwEmdLJ8DscKNTkTqPbNwLNNBjuSzaG9Vp2KGtKJr',
                    'USDT': 'Gh9ZwEmdLJ8DscKNTkTqPbNwLNNBjuSzaG9Vp2KGtKJr'
                }
            };

            // For custom tokens, get from localStorage
            const customTokens = JSON.parse(localStorage.getItem('createdTokens') || '{}');
            const networkTokens = { ...tokenAddresses[selectedNetwork], ...customTokens };

            if (!networkTokens[tokenSymbol]) {
                throw new Error(`Token ${tokenSymbol} not found on ${selectedNetwork}`);
            }

            return new solanaWeb3.PublicKey(networkTokens[tokenSymbol]);
        }

        async function createAssociatedTokenAccountIfNotExists(mint, owner) {
            const associatedTokenAddress = await splToken.Token.getAssociatedTokenAddress(
                splToken.ASSOCIATED_TOKEN_PROGRAM_ID,
                splToken.TOKEN_PROGRAM_ID,
                mint,
                owner
            );

            try {
                await splToken.Token.getAccountInfo(connection, associatedTokenAddress);
                return associatedTokenAddress;
            } catch (error) {
                // Account doesn't exist, create it
                const transaction = new solanaWeb3.Transaction().add(
                    splToken.Token.createAssociatedTokenAccountInstruction(
                        splToken.ASSOCIATED_TOKEN_PROGRAM_ID,
                        splToken.TOKEN_PROGRAM_ID,
                        mint,
                        associatedTokenAddress,
                        owner,
                        new solanaWeb3.PublicKey(walletPublicKey)
                    )
                );

                const signedTransaction = await currentWallet.signTransaction(transaction);
                await connection.sendRawTransaction(signedTransaction.serialize());
                return associatedTokenAddress;
            }
        }
    </script>
</body>
</html>